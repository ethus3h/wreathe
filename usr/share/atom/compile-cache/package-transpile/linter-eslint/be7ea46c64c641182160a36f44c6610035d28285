'use strict';
'use babel';

// eslint-disable-next-line import/no-extraneous-dependencies, import/extensions

var _atom = require('atom');

var _editor = require('./validate/editor');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Internal variables
const idleCallbacks = new Set();

// Dependencies
// NOTE: We are not directly requiring these in order to reduce the time it
// takes to require this file as that causes delays in Atom loading this package
let path;
let helpers;
let workerHelpers;
let isConfigAtHomeRoot;

const loadDeps = () => {
  if (!path) {
    path = require('path');
  }
  if (!helpers) {
    helpers = require('./helpers');
  }
  if (!workerHelpers) {
    workerHelpers = require('./worker-helpers');
  }
  if (!isConfigAtHomeRoot) {
    isConfigAtHomeRoot = require('./is-config-at-home-root');
  }
};

const makeIdleCallback = work => {
  let callbackId;
  const callBack = () => {
    idleCallbacks.delete(callbackId);
    work();
  };
  callbackId = window.requestIdleCallback(callBack);
  idleCallbacks.add(callbackId);
};

const scheduleIdleTasks = () => {
  const linterEslintInstallPeerPackages = () => {
    require('atom-package-deps').install('linter-eslint');
  };
  const linterEslintLoadDependencies = loadDeps;
  const linterEslintStartWorker = () => {
    loadDeps();
    helpers.startWorker();
  };

  if (!atom.inSpecMode()) {
    makeIdleCallback(linterEslintInstallPeerPackages);
    makeIdleCallback(linterEslintLoadDependencies);
    makeIdleCallback(linterEslintStartWorker);
  }
};

// Configuration
const scopes = [];
let showRule;
let lintHtmlFiles;
let ignoredRulesWhenModified;
let ignoredRulesWhenFixing;
let disableWhenNoEslintConfig;
let ignoreFixableRulesWhileTyping;

// Internal functions
/**
 * Given an Array or iterable containing a list of Rule IDs, return an Object
 * to be sent to ESLint's configuration that disables those rules.
 * @param  {[iterable]} ruleIds Iterable containing ruleIds to ignore
 * @return {Object}             Object containing properties for each rule to ignore
 */
const idsToIgnoredRules = ruleIds => Array.from(ruleIds).reduce(
// 0 is the severity to turn off a rule
(ids, id) => Object.assign(ids, { [id]: 0 }), {});

module.exports = {
  activate() {
    var _this = this;

    this.subscriptions = new _atom.CompositeDisposable();

    /**
     * FIXME: Deprecated eslintRulesDir{String} option in favor of
     * eslintRulesDirs{Array<String>}. Remove in the next major release,
     * in v8.5.0, or after 2018-04.
     */
    const oldRulesdir = atom.config.get('linter-eslint.eslintRulesDir');
    if (oldRulesdir) {
      const rulesDirs = atom.config.get('linter-eslint.eslintRulesDirs');
      if (rulesDirs.length === 0) {
        atom.config.set('linter-eslint.eslintRulesDirs', [oldRulesdir]);
      }
      atom.config.unset('linter-eslint.eslintRulesDir');
    }

    const embeddedScope = 'source.js.embedded.html';
    this.subscriptions.add(atom.config.observe('linter-eslint.lintHtmlFiles', value => {
      lintHtmlFiles = value;
      if (lintHtmlFiles) {
        scopes.push(embeddedScope);
      } else if (scopes.indexOf(embeddedScope) !== -1) {
        scopes.splice(scopes.indexOf(embeddedScope), 1);
      }
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.scopes', value => {
      // Remove any old scopes
      scopes.splice(0, scopes.length);
      // Add the current scopes
      Array.prototype.push.apply(scopes, value);
      // Ensure HTML linting still works if the setting is updated
      if (lintHtmlFiles && !scopes.includes(embeddedScope)) {
        scopes.push(embeddedScope);
      }
    }));

    this.subscriptions.add(atom.workspace.observeTextEditors(editor => {
      editor.onDidSave(_asyncToGenerator(function* () {
        if ((0, _editor.hasValidScope)(editor, scopes) && atom.config.get('linter-eslint.fixOnSave')) {
          yield _this.fixJob(true);
        }
      }));
    }));

    this.subscriptions.add(atom.commands.add('atom-text-editor', {
      'linter-eslint:debug': (() => {
        var _ref2 = _asyncToGenerator(function* () {
          loadDeps();
          const debugString = yield helpers.generateDebugString();
          const notificationOptions = { detail: debugString, dismissable: true };
          atom.notifications.addInfo('linter-eslint debugging information', notificationOptions);
        });

        return function linterEslintDebug() {
          return _ref2.apply(this, arguments);
        };
      })()
    }));

    this.subscriptions.add(atom.commands.add('atom-text-editor', {
      'linter-eslint:fix-file': (() => {
        var _ref3 = _asyncToGenerator(function* () {
          yield _this.fixJob();
        });

        return function linterEslintFixFile() {
          return _ref3.apply(this, arguments);
        };
      })()
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.showRuleIdInMessage', value => {
      showRule = value;
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.disableWhenNoEslintConfig', value => {
      disableWhenNoEslintConfig = value;
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.rulesToSilenceWhileTyping', ids => {
      ignoredRulesWhenModified = ids;
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.rulesToDisableWhileFixing', ids => {
      ignoredRulesWhenFixing = idsToIgnoredRules(ids);
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.ignoreFixableRulesWhileTyping', value => {
      ignoreFixableRulesWhileTyping = value;
    }));

    this.subscriptions.add(atom.contextMenu.add({
      'atom-text-editor:not(.mini), .overlayer': [{
        label: 'ESLint Fix',
        command: 'linter-eslint:fix-file',
        shouldDisplay: evt => {
          const activeEditor = atom.workspace.getActiveTextEditor();
          if (!activeEditor) {
            return false;
          }
          // Black magic!
          // Compares the private component property of the active TextEditor
          //   against the components of the elements
          const evtIsActiveEditor = evt.path.some(elem =>
          // Atom v1.19.0+
          elem.component && activeEditor.component && elem.component === activeEditor.component);
          // Only show if it was the active editor and it is a valid scope
          return evtIsActiveEditor && (0, _editor.hasValidScope)(activeEditor, scopes);
        }
      }]
    }));

    scheduleIdleTasks();
  },

  deactivate() {
    idleCallbacks.forEach(callbackID => window.cancelIdleCallback(callbackID));
    idleCallbacks.clear();
    if (helpers) {
      // If the helpers module hasn't been loaded then there was no chance a
      // worker was started anyway.
      helpers.killWorker();
    }
    this.subscriptions.dispose();
  },

  provideLinter() {
    return {
      name: 'ESLint',
      grammarScopes: scopes,
      scope: 'file',
      lintsOnChange: true,
      lint: (() => {
        var _ref4 = _asyncToGenerator(function* (textEditor) {
          if (!atom.workspace.isTextEditor(textEditor)) {
            // If we somehow get fed an invalid TextEditor just immediately return
            return null;
          }

          const filePath = textEditor.getPath();
          if (!filePath) {
            // The editor currently has no path, we can't report messages back to
            // Linter so just return null
            return null;
          }

          loadDeps();

          if (filePath.includes('://')) {
            // If the path is a URL (Nuclide remote file) return a message
            // telling the user we are unable to work on remote files.
            return helpers.generateUserMessage(textEditor, {
              severity: 'warning',
              excerpt: 'Remote file open, linter-eslint is disabled for this file.'
            });
          }

          const text = textEditor.getText();

          let rules = {};
          if (textEditor.isModified()) {
            if (ignoreFixableRulesWhileTyping) {
              // Note that the fixable rules will only have values after the first lint job
              const ignoredRules = new Set(helpers.rules.getFixableRules());
              ignoredRulesWhenModified.forEach(function (ruleId) {
                return ignoredRules.add(ruleId);
              });
              rules = idsToIgnoredRules(ignoredRules);
            } else {
              rules = idsToIgnoredRules(ignoredRulesWhenModified);
            }
          }

          try {
            const response = yield helpers.sendJob({
              type: 'lint',
              contents: text,
              config: atom.config.get('linter-eslint'),
              rules,
              filePath,
              projectPath: atom.project.relativizePath(filePath)[0] || ''
            });
            if (textEditor.getText() !== text) {
              /*
              The editor text has been modified since the lint was triggered,
              as we can't be sure that the results will map properly back to
              the new contents, simply return `null` to tell the
              `provideLinter` consumer not to update the saved results.
              */
              return null;
            }
            return helpers.processJobResponse(response, textEditor, showRule);
          } catch (error) {
            return helpers.handleError(textEditor, error);
          }
        });

        return function lint(_x) {
          return _ref4.apply(this, arguments);
        };
      })()
    };
  },

  fixJob(isSave = false) {
    return _asyncToGenerator(function* () {
      const textEditor = atom.workspace.getActiveTextEditor();

      if (!textEditor || !atom.workspace.isTextEditor(textEditor)) {
        // Silently return if the TextEditor is invalid
        return;
      }

      loadDeps();

      if (textEditor.isModified()) {
        // Abort for invalid or unsaved text editors
        const message = 'Linter-ESLint: Please save before fixing';
        atom.notifications.addError(message);
      }

      const filePath = textEditor.getPath();
      const fileDir = path.dirname(filePath);
      const projectPath = atom.project.relativizePath(filePath)[0];

      // Get the text from the editor, so we can use executeOnText
      const text = textEditor.getText();
      // Do not try to make fixes on an empty file
      if (text.length === 0) {
        return;
      }

      // Do not try to fix if linting should be disabled
      const configPath = workerHelpers.getConfigPath(fileDir);
      const noProjectConfig = configPath === null || isConfigAtHomeRoot(configPath);
      if (noProjectConfig && disableWhenNoEslintConfig) {
        return;
      }

      let rules = {};
      if (Object.keys(ignoredRulesWhenFixing).length > 0) {
        rules = ignoredRulesWhenFixing;
      }

      try {
        const response = yield helpers.sendJob({
          type: 'fix',
          config: atom.config.get('linter-eslint'),
          contents: text,
          rules,
          filePath,
          projectPath
        });
        if (!isSave) {
          atom.notifications.addSuccess(response);
        }
      } catch (err) {
        atom.notifications.addWarning(err.message);
      }
    })();
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaWRsZUNhbGxiYWNrcyIsIlNldCIsInBhdGgiLCJoZWxwZXJzIiwid29ya2VySGVscGVycyIsImlzQ29uZmlnQXRIb21lUm9vdCIsImxvYWREZXBzIiwicmVxdWlyZSIsIm1ha2VJZGxlQ2FsbGJhY2siLCJ3b3JrIiwiY2FsbGJhY2tJZCIsImNhbGxCYWNrIiwiZGVsZXRlIiwid2luZG93IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImFkZCIsInNjaGVkdWxlSWRsZVRhc2tzIiwibGludGVyRXNsaW50SW5zdGFsbFBlZXJQYWNrYWdlcyIsImluc3RhbGwiLCJsaW50ZXJFc2xpbnRMb2FkRGVwZW5kZW5jaWVzIiwibGludGVyRXNsaW50U3RhcnRXb3JrZXIiLCJzdGFydFdvcmtlciIsImF0b20iLCJpblNwZWNNb2RlIiwic2NvcGVzIiwic2hvd1J1bGUiLCJsaW50SHRtbEZpbGVzIiwiaWdub3JlZFJ1bGVzV2hlbk1vZGlmaWVkIiwiaWdub3JlZFJ1bGVzV2hlbkZpeGluZyIsImRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWciLCJpZ25vcmVGaXhhYmxlUnVsZXNXaGlsZVR5cGluZyIsImlkc1RvSWdub3JlZFJ1bGVzIiwicnVsZUlkcyIsIkFycmF5IiwiZnJvbSIsInJlZHVjZSIsImlkcyIsImlkIiwiT2JqZWN0IiwiYXNzaWduIiwibW9kdWxlIiwiZXhwb3J0cyIsImFjdGl2YXRlIiwic3Vic2NyaXB0aW9ucyIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJvbGRSdWxlc2RpciIsImNvbmZpZyIsImdldCIsInJ1bGVzRGlycyIsImxlbmd0aCIsInNldCIsInVuc2V0IiwiZW1iZWRkZWRTY29wZSIsIm9ic2VydmUiLCJ2YWx1ZSIsInB1c2giLCJpbmRleE9mIiwic3BsaWNlIiwicHJvdG90eXBlIiwiYXBwbHkiLCJpbmNsdWRlcyIsIndvcmtzcGFjZSIsIm9ic2VydmVUZXh0RWRpdG9ycyIsImVkaXRvciIsIm9uRGlkU2F2ZSIsImZpeEpvYiIsImNvbW1hbmRzIiwiZGVidWdTdHJpbmciLCJnZW5lcmF0ZURlYnVnU3RyaW5nIiwibm90aWZpY2F0aW9uT3B0aW9ucyIsImRldGFpbCIsImRpc21pc3NhYmxlIiwibm90aWZpY2F0aW9ucyIsImFkZEluZm8iLCJjb250ZXh0TWVudSIsImxhYmVsIiwiY29tbWFuZCIsInNob3VsZERpc3BsYXkiLCJldnQiLCJhY3RpdmVFZGl0b3IiLCJnZXRBY3RpdmVUZXh0RWRpdG9yIiwiZXZ0SXNBY3RpdmVFZGl0b3IiLCJzb21lIiwiZWxlbSIsImNvbXBvbmVudCIsImRlYWN0aXZhdGUiLCJmb3JFYWNoIiwiY2FsbGJhY2tJRCIsImNhbmNlbElkbGVDYWxsYmFjayIsImNsZWFyIiwia2lsbFdvcmtlciIsImRpc3Bvc2UiLCJwcm92aWRlTGludGVyIiwibmFtZSIsImdyYW1tYXJTY29wZXMiLCJzY29wZSIsImxpbnRzT25DaGFuZ2UiLCJsaW50IiwidGV4dEVkaXRvciIsImlzVGV4dEVkaXRvciIsImZpbGVQYXRoIiwiZ2V0UGF0aCIsImdlbmVyYXRlVXNlck1lc3NhZ2UiLCJzZXZlcml0eSIsImV4Y2VycHQiLCJ0ZXh0IiwiZ2V0VGV4dCIsInJ1bGVzIiwiaXNNb2RpZmllZCIsImlnbm9yZWRSdWxlcyIsImdldEZpeGFibGVSdWxlcyIsInJ1bGVJZCIsInJlc3BvbnNlIiwic2VuZEpvYiIsInR5cGUiLCJjb250ZW50cyIsInByb2plY3RQYXRoIiwicHJvamVjdCIsInJlbGF0aXZpemVQYXRoIiwicHJvY2Vzc0pvYlJlc3BvbnNlIiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsImlzU2F2ZSIsIm1lc3NhZ2UiLCJhZGRFcnJvciIsImZpbGVEaXIiLCJkaXJuYW1lIiwiY29uZmlnUGF0aCIsImdldENvbmZpZ1BhdGgiLCJub1Byb2plY3RDb25maWciLCJrZXlzIiwiYWRkU3VjY2VzcyIsImVyciIsImFkZFdhcm5pbmciXSwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUVBO0FB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QWIsQ0FBNEJsQixRQUE1QixFQUFzQyxDQUF0QyxDQUFwQjs7QUFFQTtBQUNBLFlBQU1LLE9BQU9QLFdBQVdRLE9BQVgsRUFBYjtBQUNBO0FBQ0EsVUFBSUQsS0FBS3hELE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckI7QUFDRDs7QUFFRDtBQUNBLFlBQU04RSxhQUFhM0gsY0FBYzRILGFBQWQsQ0FBNEJILE9BQTVCLENBQW5CO0FBQ0EsWUFBTUksa0JBQW1CRixlQUFlLElBQWYsSUFBdUIxSCxtQkFBbUIwSCxVQUFuQixDQUFoRDtBQUNBLFVBQUlFLG1CQUFtQnBHLHlCQUF2QixFQUFrRDtBQUNoRDtBQUNEOztBQUVELFVBQUk4RSxRQUFRLEVBQVo7QUFDQSxVQUFJckUsT0FBTzRGLElBQVAsQ0FBWXRHLHNCQUFaLEVBQW9DcUIsTUFBcEMsR0FBNkMsQ0FBakQsRUFBb0Q7QUFDbEQwRCxnQkFBUS9FLHNCQUFSO0FBQ0Q7O0FBRUQsVUFBSTtBQUNGLGNBQU1vRixXQUFXLE1BQU03RyxRQUFROEcsT0FBUixDQUFnQjtBQUNyQ0MsZ0JBQU0sS0FEK0I7QUFFckNwRSxrQkFBUXhCLEtBQUt3QixNQUFMLENBQVlDLEdBQVosQ0FBZ0IsZUFBaEIsQ0FGNkI7QUFHckNvRSxvQkFBVVYsSUFIMkI7QUFJckNFLGVBSnFDO0FBS3JDUCxrQkFMcUM7QUFNckNnQjtBQU5xQyxTQUFoQixDQUF2QjtBQVFBLFlBQUksQ0FBQ00sTUFBTCxFQUFhO0FBQ1hwRyxlQUFLa0QsYUFBTCxDQUFtQjJELFVBQW5CLENBQThCbkIsUUFBOUI7QUFDRDtBQUNGLE9BWkQsQ0FZRSxPQUFPb0IsR0FBUCxFQUFZO0FBQ1o5RyxhQUFLa0QsYUFBTCxDQUFtQjZELFVBQW5CLENBQThCRCxJQUFJVCxPQUFsQztBQUNEO0FBckQwQjtBQXNENUI7QUEvUGMsQ0FBakIiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIvbGlicmFyeS9FbWJlciBzYXRlbGxpdGUgcHJvamVjdHMvd3JlYXRoZS1iYXNlL3Vzci9zaGFyZS9hdG9tL3BhY2thZ2VzL2xpbnRlci1lc2xpbnQvc3JjIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCdcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L2V4dGVuc2lvbnNcbmltcG9ydCB7IENvbXBvc2l0ZURpc3Bvc2FibGUgfSBmcm9tICdhdG9tJ1xuaW1wb3J0IHsgaGFzVmFsaWRTY29wZSB9IGZyb20gJy4vdmFsaWRhdGUvZWRpdG9yJ1xuXG4vLyBJbnRlcm5hbCB2YXJpYWJsZXNcbmNvbnN0IGlkbGVDYWxsYmFja3MgPSBuZXcgU2V0KClcblxuLy8gRGVwZW5kZW5jaWVzXG4vLyBOT1RFOiBXZSBhcmUgbm90IGRpcmVjdGx5IHJlcXVpcmluZyB0aGVzZSBpbiBvcmRlciB0byByZWR1Y2UgdGhlIHRpbWUgaXRcbi8vIHRha2VzIHRvIHJlcXVpcmUgdGhpcyBmaWxlIGFzIHRoYXQgY2F1c2VzIGRlbGF5cyBpbiBBdG9tIGxvYWRpbmcgdGhpcyBwYWNrYWdlXG5sZXQgcGF0aFxubGV0IGhlbHBlcnNcbmxldCB3b3JrZXJIZWxwZXJzXG5sZXQgaXNDb25maWdBdEhvbWVSb290XG5cbmNvbnN0IGxvYWREZXBzID0gKCkgPT4ge1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gIH1cbiAgaWYgKCFoZWxwZXJzKSB7XG4gICAgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpXG4gIH1cbiAgaWYgKCF3b3JrZXJIZWxwZXJzKSB7XG4gICAgd29ya2VySGVscGVycyA9IHJlcXVpcmUoJy4vd29ya2VyLWhlbHBlcnMnKVxuICB9XG4gIGlmICghaXNDb25maWdBdEhvbWVSb290KSB7XG4gICAgaXNDb25maWdBdEhvbWVSb290ID0gcmVxdWlyZSgnLi9pcy1jb25maWctYXQtaG9tZS1yb290JylcbiAgfVxufVxuXG5jb25zdCBtYWtlSWRsZUNhbGxiYWNrID0gKHdvcmspID0+IHtcbiAgbGV0IGNhbGxiYWNrSWRcbiAgY29uc3QgY2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgaWRsZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2tJZClcbiAgICB3b3JrKClcbiAgfVxuICBjYWxsYmFja0lkID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soY2FsbEJhY2spXG4gIGlkbGVDYWxsYmFja3MuYWRkKGNhbGxiYWNrSWQpXG59XG5cbmNvbnN0IHNjaGVkdWxlSWRsZVRhc2tzID0gKCkgPT4ge1xuICBjb25zdCBsaW50ZXJFc2xpbnRJbnN0YWxsUGVlclBhY2thZ2VzID0gKCkgPT4ge1xuICAgIHJlcXVpcmUoJ2F0b20tcGFja2FnZS1kZXBzJykuaW5zdGFsbCgnbGludGVyLWVzbGludCcpXG4gIH1cbiAgY29uc3QgbGludGVyRXNsaW50TG9hZERlcGVuZGVuY2llcyA9IGxvYWREZXBzXG4gIGNvbnN0IGxpbnRlckVzbGludFN0YXJ0V29ya2VyID0gKCkgPT4ge1xuICAgIGxvYWREZXBzKClcbiAgICBoZWxwZXJzLnN0YXJ0V29ya2VyKClcbiAgfVxuXG4gIGlmICghYXRvbS5pblNwZWNNb2RlKCkpIHtcbiAgICBtYWtlSWRsZUNhbGxiYWNrKGxpbnRlckVzbGludEluc3RhbGxQZWVyUGFja2FnZXMpXG4gICAgbWFrZUlkbGVDYWxsYmFjayhsaW50ZXJFc2xpbnRMb2FkRGVwZW5kZW5jaWVzKVxuICAgIG1ha2VJZGxlQ2FsbGJhY2sobGludGVyRXNsaW50U3RhcnRXb3JrZXIpXG4gIH1cbn1cblxuLy8gQ29uZmlndXJhdGlvblxuY29uc3Qgc2NvcGVzID0gW11cbmxldCBzaG93UnVsZVxubGV0IGxpbnRIdG1sRmlsZXNcbmxldCBpZ25vcmVkUnVsZXNXaGVuTW9kaWZpZWRcbmxldCBpZ25vcmVkUnVsZXNXaGVuRml4aW5nXG5sZXQgZGlzYWJsZVdoZW5Ob0VzbGludENvbmZpZ1xubGV0IGlnbm9yZUZpeGFibGVSdWxlc1doaWxlVHlwaW5nXG5cbi8vIEludGVybmFsIGZ1bmN0aW9uc1xuLyoqXG4gKiBHaXZlbiBhbiBBcnJheSBvciBpdGVyYWJsZSBjb250YWluaW5nIGEgbGlzdCBvZiBSdWxlIElEcywgcmV0dXJuIGFuIE9iamVjdFxuICogdG8gYmUgc2VudCB0byBFU0xpbnQncyBjb25maWd1cmF0aW9uIHRoYXQgZGlzYWJsZXMgdGhvc2UgcnVsZXMuXG4gKiBAcGFyYW0gIHtbaXRlcmFibGVdfSBydWxlSWRzIEl0ZXJhYmxlIGNvbnRhaW5pbmcgcnVsZUlkcyB0byBpZ25vcmVcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBmb3IgZWFjaCBydWxlIHRvIGlnbm9yZVxuICovXG5jb25zdCBpZHNUb0lnbm9yZWRSdWxlcyA9IHJ1bGVJZHMgPT5cbiAgQXJyYXkuZnJvbShydWxlSWRzKS5yZWR1Y2UoXG4gICAgLy8gMCBpcyB0aGUgc2V2ZXJpdHkgdG8gdHVybiBvZmYgYSBydWxlXG4gICAgKGlkcywgaWQpID0+IE9iamVjdC5hc3NpZ24oaWRzLCB7IFtpZF06IDAgfSlcbiAgICAsIHt9XG4gIClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKVxuXG4gICAgLyoqXG4gICAgICogRklYTUU6IERlcHJlY2F0ZWQgZXNsaW50UnVsZXNEaXJ7U3RyaW5nfSBvcHRpb24gaW4gZmF2b3Igb2ZcbiAgICAgKiBlc2xpbnRSdWxlc0RpcnN7QXJyYXk8U3RyaW5nPn0uIFJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLFxuICAgICAqIGluIHY4LjUuMCwgb3IgYWZ0ZXIgMjAxOC0wNC5cbiAgICAgKi9cbiAgICBjb25zdCBvbGRSdWxlc2RpciA9IGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludC5lc2xpbnRSdWxlc0RpcicpXG4gICAgaWYgKG9sZFJ1bGVzZGlyKSB7XG4gICAgICBjb25zdCBydWxlc0RpcnMgPSBhdG9tLmNvbmZpZy5nZXQoJ2xpbnRlci1lc2xpbnQuZXNsaW50UnVsZXNEaXJzJylcbiAgICAgIGlmIChydWxlc0RpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGF0b20uY29uZmlnLnNldCgnbGludGVyLWVzbGludC5lc2xpbnRSdWxlc0RpcnMnLCBbb2xkUnVsZXNkaXJdKVxuICAgICAgfVxuICAgICAgYXRvbS5jb25maWcudW5zZXQoJ2xpbnRlci1lc2xpbnQuZXNsaW50UnVsZXNEaXInKVxuICAgIH1cblxuICAgIGNvbnN0IGVtYmVkZGVkU2NvcGUgPSAnc291cmNlLmpzLmVtYmVkZGVkLmh0bWwnXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKFxuICAgICAgJ2xpbnRlci1lc2xpbnQubGludEh0bWxGaWxlcycsXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgbGludEh0bWxGaWxlcyA9IHZhbHVlXG4gICAgICAgIGlmIChsaW50SHRtbEZpbGVzKSB7XG4gICAgICAgICAgc2NvcGVzLnB1c2goZW1iZWRkZWRTY29wZSlcbiAgICAgICAgfSBlbHNlIGlmIChzY29wZXMuaW5kZXhPZihlbWJlZGRlZFNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICBzY29wZXMuc3BsaWNlKHNjb3Blcy5pbmRleE9mKGVtYmVkZGVkU2NvcGUpLCAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZShcbiAgICAgICdsaW50ZXItZXNsaW50LnNjb3BlcycsXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBvbGQgc2NvcGVzXG4gICAgICAgIHNjb3Blcy5zcGxpY2UoMCwgc2NvcGVzLmxlbmd0aClcbiAgICAgICAgLy8gQWRkIHRoZSBjdXJyZW50IHNjb3Blc1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzY29wZXMsIHZhbHVlKVxuICAgICAgICAvLyBFbnN1cmUgSFRNTCBsaW50aW5nIHN0aWxsIHdvcmtzIGlmIHRoZSBzZXR0aW5nIGlzIHVwZGF0ZWRcbiAgICAgICAgaWYgKGxpbnRIdG1sRmlsZXMgJiYgIXNjb3Blcy5pbmNsdWRlcyhlbWJlZGRlZFNjb3BlKSkge1xuICAgICAgICAgIHNjb3Blcy5wdXNoKGVtYmVkZGVkU2NvcGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLndvcmtzcGFjZS5vYnNlcnZlVGV4dEVkaXRvcnMoKGVkaXRvcikgPT4ge1xuICAgICAgZWRpdG9yLm9uRGlkU2F2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChoYXNWYWxpZFNjb3BlKGVkaXRvciwgc2NvcGVzKVxuICAgICAgICAgICYmIGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludC5maXhPblNhdmUnKVxuICAgICAgICApIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmZpeEpvYih0cnVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbW1hbmRzLmFkZCgnYXRvbS10ZXh0LWVkaXRvcicsIHtcbiAgICAgICdsaW50ZXItZXNsaW50OmRlYnVnJzogYXN5bmMgKCkgPT4ge1xuICAgICAgICBsb2FkRGVwcygpXG4gICAgICAgIGNvbnN0IGRlYnVnU3RyaW5nID0gYXdhaXQgaGVscGVycy5nZW5lcmF0ZURlYnVnU3RyaW5nKClcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uT3B0aW9ucyA9IHsgZGV0YWlsOiBkZWJ1Z1N0cmluZywgZGlzbWlzc2FibGU6IHRydWUgfVxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkSW5mbygnbGludGVyLWVzbGludCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24nLCBub3RpZmljYXRpb25PcHRpb25zKVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbW1hbmRzLmFkZCgnYXRvbS10ZXh0LWVkaXRvcicsIHtcbiAgICAgICdsaW50ZXItZXNsaW50OmZpeC1maWxlJzogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmZpeEpvYigpXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoXG4gICAgICAnbGludGVyLWVzbGludC5zaG93UnVsZUlkSW5NZXNzYWdlJyxcbiAgICAgICh2YWx1ZSkgPT4geyBzaG93UnVsZSA9IHZhbHVlIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKFxuICAgICAgJ2xpbnRlci1lc2xpbnQuZGlzYWJsZVdoZW5Ob0VzbGludENvbmZpZycsXG4gICAgICAodmFsdWUpID0+IHsgZGlzYWJsZVdoZW5Ob0VzbGludENvbmZpZyA9IHZhbHVlIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKFxuICAgICAgJ2xpbnRlci1lc2xpbnQucnVsZXNUb1NpbGVuY2VXaGlsZVR5cGluZycsXG4gICAgICAoaWRzKSA9PiB7IGlnbm9yZWRSdWxlc1doZW5Nb2RpZmllZCA9IGlkcyB9XG4gICAgKSlcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZShcbiAgICAgICdsaW50ZXItZXNsaW50LnJ1bGVzVG9EaXNhYmxlV2hpbGVGaXhpbmcnLFxuICAgICAgKGlkcykgPT4geyBpZ25vcmVkUnVsZXNXaGVuRml4aW5nID0gaWRzVG9JZ25vcmVkUnVsZXMoaWRzKSB9XG4gICAgKSlcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZShcbiAgICAgICdsaW50ZXItZXNsaW50Lmlnbm9yZUZpeGFibGVSdWxlc1doaWxlVHlwaW5nJyxcbiAgICAgICh2YWx1ZSkgPT4geyBpZ25vcmVGaXhhYmxlUnVsZXNXaGlsZVR5cGluZyA9IHZhbHVlIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbnRleHRNZW51LmFkZCh7XG4gICAgICAnYXRvbS10ZXh0LWVkaXRvcjpub3QoLm1pbmkpLCAub3ZlcmxheWVyJzogW3tcbiAgICAgICAgbGFiZWw6ICdFU0xpbnQgRml4JyxcbiAgICAgICAgY29tbWFuZDogJ2xpbnRlci1lc2xpbnQ6Zml4LWZpbGUnLFxuICAgICAgICBzaG91bGREaXNwbGF5OiAoZXZ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlRWRpdG9yID0gYXRvbS53b3Jrc3BhY2UuZ2V0QWN0aXZlVGV4dEVkaXRvcigpXG4gICAgICAgICAgaWYgKCFhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCbGFjayBtYWdpYyFcbiAgICAgICAgICAvLyBDb21wYXJlcyB0aGUgcHJpdmF0ZSBjb21wb25lbnQgcHJvcGVydHkgb2YgdGhlIGFjdGl2ZSBUZXh0RWRpdG9yXG4gICAgICAgICAgLy8gICBhZ2FpbnN0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBlbGVtZW50c1xuICAgICAgICAgIGNvbnN0IGV2dElzQWN0aXZlRWRpdG9yID0gZXZ0LnBhdGguc29tZShlbGVtID0+XG4gICAgICAgICAgICAvLyBBdG9tIHYxLjE5LjArXG4gICAgICAgICAgICAoZWxlbS5jb21wb25lbnQgJiYgYWN0aXZlRWRpdG9yLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgICBlbGVtLmNvbXBvbmVudCA9PT0gYWN0aXZlRWRpdG9yLmNvbXBvbmVudCkpXG4gICAgICAgICAgLy8gT25seSBzaG93IGlmIGl0IHdhcyB0aGUgYWN0aXZlIGVkaXRvciBhbmQgaXQgaXMgYSB2YWxpZCBzY29wZVxuICAgICAgICAgIHJldHVybiBldnRJc0FjdGl2ZUVkaXRvciAmJiBoYXNWYWxpZFNjb3BlKGFjdGl2ZUVkaXRvciwgc2NvcGVzKVxuICAgICAgICB9XG4gICAgICB9XVxuICAgIH0pKVxuXG4gICAgc2NoZWR1bGVJZGxlVGFza3MoKVxuICB9LFxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgaWRsZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrSUQgPT4gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhjYWxsYmFja0lEKSlcbiAgICBpZGxlQ2FsbGJhY2tzLmNsZWFyKClcbiAgICBpZiAoaGVscGVycykge1xuICAgICAgLy8gSWYgdGhlIGhlbHBlcnMgbW9kdWxlIGhhc24ndCBiZWVuIGxvYWRlZCB0aGVuIHRoZXJlIHdhcyBubyBjaGFuY2UgYVxuICAgICAgLy8gd29ya2VyIHdhcyBzdGFydGVkIGFueXdheS5cbiAgICAgIGhlbHBlcnMua2lsbFdvcmtlcigpXG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kaXNwb3NlKClcbiAgfSxcblxuICBwcm92aWRlTGludGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnRVNMaW50JyxcbiAgICAgIGdyYW1tYXJTY29wZXM6IHNjb3BlcyxcbiAgICAgIHNjb3BlOiAnZmlsZScsXG4gICAgICBsaW50c09uQ2hhbmdlOiB0cnVlLFxuICAgICAgbGludDogYXN5bmMgKHRleHRFZGl0b3IpID0+IHtcbiAgICAgICAgaWYgKCFhdG9tLndvcmtzcGFjZS5pc1RleHRFZGl0b3IodGV4dEVkaXRvcikpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBzb21laG93IGdldCBmZWQgYW4gaW52YWxpZCBUZXh0RWRpdG9yIGp1c3QgaW1tZWRpYXRlbHkgcmV0dXJuXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKClcbiAgICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICAgIC8vIFRoZSBlZGl0b3IgY3VycmVudGx5IGhhcyBubyBwYXRoLCB3ZSBjYW4ndCByZXBvcnQgbWVzc2FnZXMgYmFjayB0b1xuICAgICAgICAgIC8vIExpbnRlciBzbyBqdXN0IHJldHVybiBudWxsXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWREZXBzKClcblxuICAgICAgICBpZiAoZmlsZVBhdGguaW5jbHVkZXMoJzovLycpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgYSBVUkwgKE51Y2xpZGUgcmVtb3RlIGZpbGUpIHJldHVybiBhIG1lc3NhZ2VcbiAgICAgICAgICAvLyB0ZWxsaW5nIHRoZSB1c2VyIHdlIGFyZSB1bmFibGUgdG8gd29yayBvbiByZW1vdGUgZmlsZXMuXG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZ2VuZXJhdGVVc2VyTWVzc2FnZSh0ZXh0RWRpdG9yLCB7XG4gICAgICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgZXhjZXJwdDogJ1JlbW90ZSBmaWxlIG9wZW4sIGxpbnRlci1lc2xpbnQgaXMgZGlzYWJsZWQgZm9yIHRoaXMgZmlsZS4nLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dEVkaXRvci5nZXRUZXh0KClcblxuICAgICAgICBsZXQgcnVsZXMgPSB7fVxuICAgICAgICBpZiAodGV4dEVkaXRvci5pc01vZGlmaWVkKCkpIHtcbiAgICAgICAgICBpZiAoaWdub3JlRml4YWJsZVJ1bGVzV2hpbGVUeXBpbmcpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgZml4YWJsZSBydWxlcyB3aWxsIG9ubHkgaGF2ZSB2YWx1ZXMgYWZ0ZXIgdGhlIGZpcnN0IGxpbnQgam9iXG4gICAgICAgICAgICBjb25zdCBpZ25vcmVkUnVsZXMgPSBuZXcgU2V0KGhlbHBlcnMucnVsZXMuZ2V0Rml4YWJsZVJ1bGVzKCkpXG4gICAgICAgICAgICBpZ25vcmVkUnVsZXNXaGVuTW9kaWZpZWQuZm9yRWFjaChydWxlSWQgPT4gaWdub3JlZFJ1bGVzLmFkZChydWxlSWQpKVxuICAgICAgICAgICAgcnVsZXMgPSBpZHNUb0lnbm9yZWRSdWxlcyhpZ25vcmVkUnVsZXMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVzID0gaWRzVG9JZ25vcmVkUnVsZXMoaWdub3JlZFJ1bGVzV2hlbk1vZGlmaWVkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoZWxwZXJzLnNlbmRKb2Ioe1xuICAgICAgICAgICAgdHlwZTogJ2xpbnQnLFxuICAgICAgICAgICAgY29udGVudHM6IHRleHQsXG4gICAgICAgICAgICBjb25maWc6IGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludCcpLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgIHByb2plY3RQYXRoOiBhdG9tLnByb2plY3QucmVsYXRpdml6ZVBhdGgoZmlsZVBhdGgpWzBdIHx8ICcnXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAodGV4dEVkaXRvci5nZXRUZXh0KCkgIT09IHRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBUaGUgZWRpdG9yIHRleHQgaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIGxpbnQgd2FzIHRyaWdnZXJlZCxcbiAgICAgICAgICAgIGFzIHdlIGNhbid0IGJlIHN1cmUgdGhhdCB0aGUgcmVzdWx0cyB3aWxsIG1hcCBwcm9wZXJseSBiYWNrIHRvXG4gICAgICAgICAgICB0aGUgbmV3IGNvbnRlbnRzLCBzaW1wbHkgcmV0dXJuIGBudWxsYCB0byB0ZWxsIHRoZVxuICAgICAgICAgICAgYHByb3ZpZGVMaW50ZXJgIGNvbnN1bWVyIG5vdCB0byB1cGRhdGUgdGhlIHNhdmVkIHJlc3VsdHMuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMucHJvY2Vzc0pvYlJlc3BvbnNlKHJlc3BvbnNlLCB0ZXh0RWRpdG9yLCBzaG93UnVsZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaGVscGVycy5oYW5kbGVFcnJvcih0ZXh0RWRpdG9yLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhc3luYyBmaXhKb2IoaXNTYXZlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0ZXh0RWRpdG9yID0gYXRvbS53b3Jrc3BhY2UuZ2V0QWN0aXZlVGV4dEVkaXRvcigpXG5cbiAgICBpZiAoIXRleHRFZGl0b3IgfHwgIWF0b20ud29ya3NwYWNlLmlzVGV4dEVkaXRvcih0ZXh0RWRpdG9yKSkge1xuICAgICAgLy8gU2lsZW50bHkgcmV0dXJuIGlmIHRoZSBUZXh0RWRpdG9yIGlzIGludmFsaWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxvYWREZXBzKClcblxuICAgIGlmICh0ZXh0RWRpdG9yLmlzTW9kaWZpZWQoKSkge1xuICAgICAgLy8gQWJvcnQgZm9yIGludmFsaWQgb3IgdW5zYXZlZCB0ZXh0IGVkaXRvcnNcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTGludGVyLUVTTGludDogUGxlYXNlIHNhdmUgYmVmb3JlIGZpeGluZydcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcihtZXNzYWdlKVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKClcbiAgICBjb25zdCBmaWxlRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKVxuICAgIGNvbnN0IHByb2plY3RQYXRoID0gYXRvbS5wcm9qZWN0LnJlbGF0aXZpemVQYXRoKGZpbGVQYXRoKVswXVxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0IGZyb20gdGhlIGVkaXRvciwgc28gd2UgY2FuIHVzZSBleGVjdXRlT25UZXh0XG4gICAgY29uc3QgdGV4dCA9IHRleHRFZGl0b3IuZ2V0VGV4dCgpXG4gICAgLy8gRG8gbm90IHRyeSB0byBtYWtlIGZpeGVzIG9uIGFuIGVtcHR5IGZpbGVcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERvIG5vdCB0cnkgdG8gZml4IGlmIGxpbnRpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gICAgY29uc3QgY29uZmlnUGF0aCA9IHdvcmtlckhlbHBlcnMuZ2V0Q29uZmlnUGF0aChmaWxlRGlyKVxuICAgIGNvbnN0IG5vUHJvamVjdENvbmZpZyA9IChjb25maWdQYXRoID09PSBudWxsIHx8IGlzQ29uZmlnQXRIb21lUm9vdChjb25maWdQYXRoKSlcbiAgICBpZiAobm9Qcm9qZWN0Q29uZmlnICYmIGRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBydWxlcyA9IHt9XG4gICAgaWYgKE9iamVjdC5rZXlzKGlnbm9yZWRSdWxlc1doZW5GaXhpbmcpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJ1bGVzID0gaWdub3JlZFJ1bGVzV2hlbkZpeGluZ1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhlbHBlcnMuc2VuZEpvYih7XG4gICAgICAgIHR5cGU6ICdmaXgnLFxuICAgICAgICBjb25maWc6IGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludCcpLFxuICAgICAgICBjb250ZW50czogdGV4dCxcbiAgICAgICAgcnVsZXMsXG4gICAgICAgIGZpbGVQYXRoLFxuICAgICAgICBwcm9qZWN0UGF0aFxuICAgICAgfSlcbiAgICAgIGlmICghaXNTYXZlKSB7XG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRTdWNjZXNzKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZFdhcm5pbmcoZXJyLm1lc3NhZ2UpXG4gICAgfVxuICB9LFxufVxuIl19